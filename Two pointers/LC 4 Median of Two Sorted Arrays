Link to Q: https://leetcode.com/problems/median-of-two-sorted-arrays/description/

Code:
Solution 1: Easy way
import math

class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        
        num = sorted(nums1 + nums2)
        length = len(num)
        mid = length // 2   # integer division for indexing

        if length % 2 == 0:
            return (num[mid - 1] + num[mid]) / 2.0    # float division to ensure return type = float
        else:    
            return num[mid]


Solution 2: [Proper]
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        len1 = len(nums1)
        len2 = len(nums2)
        # when total length is odd, the median is the middle
        if (len1 + len2) % 2 != 0:
            return self.get_kth(nums1, nums2, 0, len1-1, 0, len2-1, (len1+len2)//2)
        else:
        # when total length is even, the median is the average of the middle 2
            middle1 = self.get_kth(nums1, nums2, 0, len1-1, 0, len2-1, (len1+len2)//2)
            middle2 = self.get_kth(nums1, nums2, 0, len1-1, 0, len2-1, (len1+len2)//2-1)
            return (middle1 + middle2) / 2

    def get_kth(self, nums1, nums2, start1, end1, start2, end2, k):
    """
    Args:
         nums1 (list) 
         nums2 (list)
         start1, end1 (int): bounds in nums1
         start2, end2 (int): bounds in nums2
         k (index): index in the combined array of the desired element
    """


        # Base Case: Given that one of the arrays(num1/num2 are empty), the kth
                     element would be at the other element. So we skip the start
                     of the empty arrays.
        if start1 > end1:
            return nums2[k-start1]
        if start2 > end2:
            return nums1[k-start2]

        # Picking midpoints of both arrays individually
        # To determine which half to eliminate
        middle1 = (start1 + end1) // 2
        middle2 = (start2 + end2) // 2
        middle1_value = nums1[middle1]
        middle2_value = nums2[middle2]

        
        # if sum of two median's indicies is smaller than k
        # Check whether if both midpoints before the k-th element
        # discard one of the halfs if True
        if (middle1 + middle2) < k:

            # if nums1 median value bigger than nums2, then nums2's first half will always be positioned 
            # before nums1's median, so k would never be in num2's first half
            # Drop the half that has a smaller midpoint

            if middle1_value > middle2_value:
                return self.get_kth(nums1, nums2, start1, end1, middle2+1, end2, k)
            
            else:
                return self.get_kth(nums1, nums2, middle1+1, end1, start2, end2, k)

        # if sum of two median's indicies is bigger than k
        # Then we drop the half with larger midpoint
        else:
            # if nums1 median value bigger than nums2, then nums2's first half would be merged before nums1's first half, thus k always come before nums1's median, then nums1's second half would never include k
            if middle1_value > middle2_value:
                return self.get_kth(nums1, nums2, start1, middle1-1, start2, end2, k)
            else:
                return self.get_kth(nums1, nums2, start1, end1, start2, middle2-1, k)
            
